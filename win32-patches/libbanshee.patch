Index: gst-cd-rip-0.10.c
===================================================================
--- gst-cd-rip-0.10.c	(revision 2823)
+++ gst-cd-rip-0.10.c	(working copy)
@@ -60,7 +60,7 @@
     gchar *encoder_pipeline;
     
     GstElement *pipeline;
-    GstElement *cddasrc;
+    GstElement *cdparanoia;
     GstElement *encoder;
     GstElement *filesink;
     
@@ -111,7 +111,7 @@
         return TRUE;
     }
 
-    if(!gst_element_query_position(ripper->cddasrc, &format, &position)) {
+    if(!gst_element_query_position(ripper->cdparanoia, &format, &position)) {
         return TRUE;
     }
     
@@ -223,18 +223,15 @@
         return FALSE;
     }
 
-    ripper->cddasrc = gst_element_make_from_uri(GST_URI_SRC, "cdda://1", "cddasrc");
-    if(ripper->cddasrc == NULL) {
-        gst_cd_ripper_raise_error(ripper, _("Could not initialize element from cdda URI"), NULL);
+    ripper->cdparanoia = gst_element_factory_make("cdparanoiasrc", "cdparanoia");
+    if(ripper->cdparanoia == NULL) {
+        gst_cd_ripper_raise_error(ripper, _("Could not initialize cdparanoia"), NULL);
         return FALSE;
     }
   
-    g_object_set(G_OBJECT(ripper->cddasrc), "device", ripper->device, NULL);
+    g_object_set(G_OBJECT(ripper->cdparanoia), "device", ripper->device, NULL);
+    g_object_set(G_OBJECT(ripper->cdparanoia), "paranoia-mode", ripper->paranoia_mode, NULL);
     
-    if(g_object_class_find_property(G_OBJECT_GET_CLASS(ripper->cddasrc), "paranoia-mode")) {
-        g_object_set(G_OBJECT(ripper->cddasrc), "paranoia-mode", ripper->paranoia_mode, NULL);
-    }
-    
     ripper->track_format = gst_format_get_by_nick("track");
     
     mbtrm = gst_element_factory_make("mbtrm", "mbtrm");
@@ -273,15 +270,15 @@
         G_CALLBACK(gst_cd_ripper_gvfs_allow_overwrite_cb), ripper);
     
     gst_bin_add_many(GST_BIN(ripper->pipeline),
-        ripper->cddasrc,
+        ripper->cdparanoia,
         mbtrm,
         queue,
         ripper->encoder,
         ripper->filesink,
         NULL);
         
-    if(!gst_element_link(ripper->cddasrc, mbtrm)) {
-        gst_cd_ripper_raise_error(ripper, _("Could not link cddasrcsrc to mbtrm"), NULL);
+    if(!gst_element_link(ripper->cdparanoia, mbtrm)) {
+        gst_cd_ripper_raise_error(ripper, _("Could not link cdparanoiasrc to mbtrm"), NULL);
         return FALSE;
     }
         
@@ -324,7 +321,7 @@
     ripper->encoder_pipeline = g_strdup(encoder_pipeline);
     
     ripper->pipeline = NULL;
-    ripper->cddasrc = NULL;
+    ripper->cdparanoia = NULL;
     ripper->encoder = NULL;
     ripper->filesink = NULL;
     
@@ -433,7 +430,7 @@
     }
     
     // start the ripping
-    g_object_set(G_OBJECT(ripper->cddasrc), "track", track_number, NULL);
+    g_object_set(G_OBJECT(ripper->cdparanoia), "track", track_number, NULL);
     
     gst_element_set_state(ripper->pipeline, GST_STATE_PLAYING);
     gst_cd_ripper_start_iterate_timeout(ripper);
Index: gst-misc-0.10.c
===================================================================
--- gst-misc-0.10.c	(revision 2823)
+++ gst-misc-0.10.c	(working copy)
@@ -33,40 +33,17 @@
 
 #include <stdlib.h>
 #include <stdio.h>
+#ifdef WIN32
+#include "unistd.h"
+#else
 #include <unistd.h>
+#endif
 #include <string.h>
 
 #include <gst/gst.h>
 
-#ifdef HAVE_GST_PBUTILS
-#  include <gst/pbutils/pbutils.h>
-#endif
-
-#include "gst-mbtrm.h"
-
 static gboolean gstreamer_initialized = FALSE;
 
-static gboolean
-gst_mbtrm_register_elements(GstPlugin *plugin)
-{
-    return gst_element_register(plugin, "mbtrm",
-        GST_RANK_NONE, GST_TYPE_MBTRM);
-}
-
-static GstPluginDesc gst_mbtrm_plugin_desc = {
-    GST_VERSION_MAJOR,
-    GST_VERSION_MINOR,
-    "mbtrm",
-    "Private MusicBrainz TRM element",
-    gst_mbtrm_register_elements,
-    "0.10.10",
-    "LGPL",
-    "libbanshee",
-    "Banshee",
-    "http://banshee-project.org/",
-    GST_PADDING_INIT
-};
-
 void gstreamer_initialize()
 {
     if(gstreamer_initialized) {
@@ -74,12 +51,9 @@
     }
 
     gst_init(NULL, NULL);
-    
-    #ifdef HAVE_GST_PBUTILS
-    gst_pb_utils_init();
-    #endif
-    
+#ifndef WIN32 //FIXME kludgy
     _gst_plugin_register_static(&gst_mbtrm_plugin_desc);
+#endif
 
     gstreamer_initialized = TRUE;
 }
@@ -97,5 +71,4 @@
     }
     
     return error == NULL;
-}
-
+}
\ No newline at end of file
Index: gst-playback-0.10.c
===================================================================
--- gst-playback-0.10.c	(revision 2823)
+++ gst-playback-0.10.c	(working copy)
@@ -26,10 +26,6 @@
  *  DEALINGS IN THE SOFTWARE.
  */
  
-#ifdef HAVE_CONFIG_H
-#  include "config.h"
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,15 +34,6 @@
 
 #include <gst/gst.h>
 
-#ifdef HAVE_GST_PBUTILS
-#  include <gst/pbutils/pbutils.h>
-#endif
-
-#include <gdk/gdk.h>
-#ifdef GDK_WINDOWING_X11
-#include <gdk/gdkx.h>
-#endif
-
 #include "gst-tagger.h"
 
 #define IS_GST_PLAYBACK(e) (e != NULL)
@@ -80,31 +67,11 @@
     GstPlaybackIterateCallback iterate_cb;
     GstPlaybackBufferingCallback buffering_cb;
     GstTaggerTagFoundCallback tag_found_cb;
-    
-    GdkWindow *window;
-    GSList *missing_element_details;
-    gboolean install_plugins_noprompt;
-    
-    #ifdef HAVE_GST_PBUTILS
-    GstInstallPluginsContext *install_plugins_context;
-    #endif
 };
 
 // private methods
 
 static void
-gst_playback_nuke_slist(GSList *list)
-{   
-    GSList *node = list;
-    
-    for(; node != NULL; node = node->next) {
-        g_free(node->data);
-    }
-    
-    g_slist_free(list);
-}
-
-static void
 gst_playback_destroy_pipeline(GstPlayback *engine)
 {
     g_return_if_fail(IS_GST_PLAYBACK(engine));
@@ -122,89 +89,6 @@
     engine->playbin = NULL;
 }
 
-#ifdef HAVE_GST_PBUTILS
-static gchar **
-gst_playback_missing_element_details_vectorize(const GSList *elements)
-{
-    GPtrArray *vector = g_ptr_array_new();
-    
-    while(elements != NULL) {
-        g_ptr_array_add(vector, g_strdup(elements->data));
-        elements = elements->next;
-    }
-    
-    g_ptr_array_add(vector, NULL);
-    return (gchar **)g_ptr_array_free(vector, FALSE);
-}
-
-static void
-gst_playback_handle_missing_elements_failed(GstPlayback *engine)
-{
-    gst_playback_nuke_slist(engine->missing_element_details);
-    engine->missing_element_details = NULL;
-    gst_element_set_state(engine->playbin, GST_STATE_READY);
-    
-    if(engine->error_cb != NULL) {
-       engine->error_cb(engine, GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN, NULL, NULL);
-    }
-}
-
-static void
-gst_playback_handle_missing_elements_installer_result(GstInstallPluginsReturn result, gpointer data)
-{
-    GstPlayback *engine = (GstPlayback *)data;
-    
-    g_return_if_fail(IS_GST_PLAYBACK(engine));
-    
-    // TODO: Actually handle a successful plugin installation
-    // if(result == GST_INSTALL_PLUGINS_SUCCESS) {
-    // }
-    
-    engine->install_plugins_noprompt = TRUE;
-    
-    gst_playback_handle_missing_elements_failed(engine);
-    
-    gst_install_plugins_context_free(engine->install_plugins_context);
-    engine->install_plugins_context = NULL;
-}
-
-static void
-gst_playback_handle_missing_elements(GstPlayback *engine)
-{
-    GstInstallPluginsReturn install_return;
-    gchar **details;
-    
-    if(engine->install_plugins_context != NULL) {
-        return;
-    } else if(engine->install_plugins_noprompt) {
-        gst_playback_handle_missing_elements_failed(engine);
-        return;
-    }
-    
-    details = gst_playback_missing_element_details_vectorize(engine->missing_element_details);
-    engine->install_plugins_context = gst_install_plugins_context_new();
-    
-    #ifdef GDK_WINDOWING_X11
-    if(engine->window != NULL) {
-        gst_install_plugins_context_set_xid(engine->install_plugins_context, 
-        GDK_WINDOW_XWINDOW(engine->window));
-    }
-    #endif
-    
-    install_return = gst_install_plugins_async(details, engine->install_plugins_context, 
-        gst_playback_handle_missing_elements_installer_result, engine);
-    
-    if(install_return != GST_INSTALL_PLUGINS_STARTED_OK) {
-        gst_playback_handle_missing_elements_failed(engine);
-        
-        gst_install_plugins_context_free(engine->install_plugins_context);
-        engine->install_plugins_context = NULL;
-    } 
-    
-    g_strfreev(details);
-}
-#endif
-
 static gboolean
 gst_playback_bus_callback(GstBus *bus, GstMessage *message, gpointer data)
 {
@@ -220,7 +104,7 @@
             // FIXME: This is to work around a bug in qtdemux in
             // -good <= 0.10.6
             if(message->src != NULL && message->src->name != NULL &&
-                strncmp(message->src->name, "qtdemux", 0) == 0) {
+                strncmp(message->src->name, "qtdemux", 8) == 0) {
                 break;
             }
             
@@ -234,19 +118,7 @@
             }
             
             break;
-        } 
-        
-        #ifdef HAVE_GST_PBUTILS
-        case GST_MESSAGE_ELEMENT: {
-            if(gst_is_missing_plugin_message(message)) {
-                engine->missing_element_details = g_slist_append(engine->missing_element_details, 
-                    gst_missing_plugin_message_get_installer_detail(message));
-            }
-            
-            break;
-        }
-        #endif
-        
+        }        
         case GST_MESSAGE_EOS:
             if(engine->eos_cb != NULL) {
                 engine->eos_cb(engine);
@@ -255,15 +127,6 @@
         case GST_MESSAGE_STATE_CHANGED: {
             GstState old, new, pending;
             gst_message_parse_state_changed(message, &old, &new, &pending);
-            
-            #ifdef HAVE_GST_PBUTILS
-            if(old == GST_STATE_READY && new == GST_STATE_PAUSED) {
-                if(engine->missing_element_details != NULL) {
-                    gst_playback_handle_missing_elements(engine);
-                }
-            }
-            #endif
-            
             if(engine->state_changed_cb != NULL) {
                 engine->state_changed_cb(engine, old, new, pending);
             }
@@ -396,7 +259,10 @@
     g_return_val_if_fail(engine->playbin != NULL, FALSE);
 
     audiosink = gst_element_factory_make("gconfaudiosink", "audiosink");
-    g_return_val_if_fail(audiosink != NULL, FALSE);
+	if(audiosink == NULL) {
+		audiosink = gst_element_factory_make("autoaudiosink", "audiosink");
+		g_return_val_if_fail(audiosink != NULL, FALSE);
+	}
         
     /* Set the profile to "music and movies" (gst-plugins-good 0.10.3) */
     if(g_object_class_find_property(G_OBJECT_GET_CLASS(audiosink), "profile")) {
@@ -491,6 +357,18 @@
         return NULL;
     }
     
+    engine->eos_cb = NULL;
+    engine->error_cb = NULL;
+    engine->state_changed_cb = NULL;
+    engine->iterate_cb = NULL;
+    engine->buffering_cb = NULL;
+    engine->tag_found_cb = NULL;
+    
+    engine->iterate_timeout_id = 0;
+    engine->cdda_device = NULL;
+    
+    engine->buffering = FALSE;
+    
     return engine;
 }
 
@@ -510,16 +388,6 @@
         engine->cdda_device = NULL;
     }
     
-    gst_playback_nuke_slist(engine->missing_element_details);
-    engine->missing_element_details = NULL;
-    
-    #ifdef HAVE_GST_PBUTILS
-    if(engine->install_plugins_context != NULL) {
-        gst_install_plugins_context_free(engine->install_plugins_context);
-        engine->install_plugins_context = NULL;
-    }
-    #endif
-    
     g_free(engine);
     engine = NULL;
 }
@@ -577,7 +445,7 @@
         return;
     }
 
-    if(uri != NULL && g_str_has_prefix(uri, "cdda://")) {
+	if(uri != NULL && g_str_has_prefix(uri, "cdda://")) {
         const gchar *p = g_utf8_strchr(uri, -1, '#');
         const gchar *new_cdda_device;
         
@@ -746,12 +614,6 @@
 }
 
 void
-gst_playback_set_gdk_window(GstPlayback *engine, GdkWindow *window)
-{
-    engine->window = window;
-}
-
-void
 gst_playback_get_error_quarks(GQuark *core, GQuark *library, GQuark *resource, GQuark *stream)
 {
     *core = GST_CORE_ERROR;
Index: gst-tagger.c
===================================================================
--- gst-tagger.c	(revision 2823)
+++ gst-tagger.c	(working copy)
@@ -28,7 +28,11 @@
  
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef WIN32
+#include "unistd.h"
+#else
 #include <unistd.h>
+#endif
 #include <string.h>
 #include <glib.h>
 #include <glib/gstdio.h>
@@ -150,7 +154,9 @@
 static void
 gst_tagger_typefind(GstElement *typefind, guint probability, GstCaps *caps, GstTagger *tagger)
 {
-    gint i;
+    const gchar *mime = gst_structure_get_name(gst_caps_get_structure(caps, 0));
+	GValue *type_value = g_new0(GValue, 1);
+	gint i;
     gboolean allowed = FALSE;
     
     g_return_if_fail(tagger != NULL);
@@ -164,8 +170,6 @@
     if(!tagger->processing_stream ||  caps == NULL || gst_caps_get_size(caps) <= 0) {
         return;
     }
-    
-    const gchar *mime = gst_structure_get_name(gst_caps_get_structure(caps, 0));
 
     // match against the whitelist
     for(i = 0; mimetype_whitelist[i] != NULL; i++) {
@@ -188,8 +192,6 @@
         return;
     }
     
-    GValue *type_value = g_new0(GValue, 1);
-    
     g_value_init(type_value, G_TYPE_STRING);
     g_value_set_string(type_value, mime);
     
Index: gst-transcode-0.10.c
===================================================================
--- gst-transcode-0.10.c	(revision 2823)
+++ gst-transcode-0.10.c	(working copy)
@@ -34,7 +34,9 @@
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
 
+#ifndef WIN32
 #include <libgnomevfs/gnome-vfs.h>
+#endif
 
 #include "gst-misc.h"
 
@@ -124,7 +126,7 @@
 static gboolean
 gst_transcoder_bus_callback(GstBus *bus, GstMessage *message, gpointer data)
 {
-    GnomeVFSFileInfo fileinfo;
+    //GnomeVFSFileInfo fileinfo;
     GstTranscoder *transcoder = (GstTranscoder *)data;
 
     g_return_val_if_fail(transcoder != NULL, FALSE);
@@ -153,7 +155,7 @@
             transcoder->is_transcoding = FALSE;
             gst_transcoder_stop_iterate_timeout(transcoder);
 
-            if(gnome_vfs_get_file_info(transcoder->output_uri, &fileinfo, 
+            /*if(gnome_vfs_get_file_info(transcoder->output_uri, &fileinfo, 
                 GNOME_VFS_FILE_INFO_DEFAULT) == GNOME_VFS_OK) {
                 if(fileinfo.size < 100) {
                     gst_transcoder_raise_error(transcoder, 
@@ -164,7 +166,7 @@
             } else {
                 gst_transcoder_raise_error(transcoder, _("Could not stat encoded file"), NULL);
                 break;
-            }
+            }*/
             
             if(transcoder->finished_cb != NULL) {
                 transcoder->finished_cb(transcoder);
@@ -184,7 +186,16 @@
     gchar *pipeline;
     GError *error = NULL;
     
-    pipeline = g_strdup_printf("%s", encoder_pipeline); 
+    if(g_strrstr(encoder_pipeline, "cdwavenc")) {
+        pipeline = g_strdup_printf("audioresample ! audioconvert ! %s ! wavenc", 
+            "audio/x-raw-int, endianness=(int)1234, width=(int)16, "
+            "depth=(int)16, signed=(boolean)true, rate=(int)44100, "
+            "channels=(int)2"
+        );
+    } else {
+        pipeline = g_strdup_printf("%s", encoder_pipeline);
+    }
+    
     encoder = gst_parse_bin_from_description(pipeline, TRUE, &error);
     g_free(pipeline);
     
@@ -228,7 +239,7 @@
 
 static gboolean
 gst_transcoder_create_pipeline(GstTranscoder *transcoder, 
-    const char *input_file, const char *output_file, 
+    const char **input_file, const char **output_file, 
     const gchar *encoder_pipeline)
 {
     GstElement *source_elem;
@@ -237,6 +248,7 @@
     GstElement *sink_elem;
     GstElement *conv_elem;
     GstPad *encoder_pad;
+	gboolean have_gnomevfs;
 
     if(transcoder == NULL) {
         return FALSE;
@@ -244,10 +256,16 @@
     
     transcoder->pipeline = gst_pipeline_new("pipeline");
 
-    source_elem = gst_element_factory_make("gnomevfssrc", "source");
+    have_gnomevfs = TRUE;
+	
+	source_elem = gst_element_factory_make("gnomevfssrc", "source");
     if(source_elem == NULL) {
-        gst_transcoder_raise_error(transcoder, _("Could not create 'gnomevfssrc' plugin"), NULL);
-        return FALSE;
+		have_gnomevfs = FALSE;
+        source_elem = gst_element_factory_make("filesrc", "source");
+		if(source_elem == NULL) {
+			gst_transcoder_raise_error(transcoder, _("Could not create 'gnomevfssrc' or 'filesrc' plugin"), NULL);
+			return FALSE;
+		}
     }
 
     decoder_elem = gst_element_factory_make("decodebin", "decodebin");
@@ -258,8 +276,12 @@
     
     sink_elem = gst_element_factory_make("gnomevfssink", "sink");
     if(sink_elem == NULL) {
-        gst_transcoder_raise_error(transcoder, _("Could not create 'gnomevfssink' plugin"), NULL);
-        return FALSE;
+        have_gnomevfs = FALSE;
+        sink_elem = gst_element_factory_make("filesink", "source");
+		if(sink_elem == NULL) {
+			gst_transcoder_raise_error(transcoder, _("Could not create 'gnomevfssink' or 'filesink' plugin"), NULL);
+			return FALSE;
+		}
     }
     
     transcoder->sink_bin = gst_bin_new("sinkbin");
@@ -300,8 +322,17 @@
         
     gst_element_link(source_elem, decoder_elem);
 
-    g_object_set(source_elem, "location", input_file, NULL);
-    g_object_set(sink_elem, "location", output_file, NULL);
+    if(!have_gnomevfs) {
+		*input_file = g_filename_from_uri(*input_file, NULL, NULL);
+		*output_file = g_filename_from_uri(*output_file, NULL, NULL);
+	}
+	if(&input_file == NULL || &output_file == NULL) {
+		gst_transcoder_raise_error(transcoder, _("Could not convert URIs to filenames"), NULL);
+		return FALSE;
+	}
+	
+	g_object_set(source_elem, "location", *input_file, NULL);
+    g_object_set(sink_elem, "location", *output_file, NULL);
 
     g_signal_connect(decoder_elem, "new-decoded-pad", 
         G_CALLBACK(gst_transcoder_new_decoded_pad), transcoder);
@@ -358,13 +389,16 @@
 gst_transcoder_transcode(GstTranscoder *transcoder, const gchar *input_uri, 
     const gchar *output_uri, const gchar *encoder_pipeline)
 {
-    g_return_if_fail(transcoder != NULL);
+    const gchar **input = &input_uri;
+	const gchar **output = &output_uri;
+	
+	g_return_if_fail(transcoder != NULL);
     
     if(transcoder->is_transcoding) {
         return;
     }
     
-    if(!gst_transcoder_create_pipeline(transcoder, input_uri, output_uri, encoder_pipeline)) {
+    if(!gst_transcoder_create_pipeline(transcoder, input, output, encoder_pipeline)) {
         gst_transcoder_raise_error(transcoder, _("Could not construct pipeline"), NULL); 
         return;
     }
@@ -373,7 +407,7 @@
         g_free(transcoder->output_uri);
     }
     
-    transcoder->output_uri = g_strdup(output_uri);
+    transcoder->output_uri = g_strdup(*output);
     transcoder->is_transcoding = TRUE;
     
     gst_element_set_state(GST_ELEMENT(transcoder->pipeline), GST_STATE_PLAYING);
Index: misc-glue.c
===================================================================
--- misc-glue.c	(revision 2823)
+++ misc-glue.c	(working copy)
@@ -1,5 +1,7 @@
 #include <gtk/gtk.h>
+#ifndef WIN32 // FIXME this is kinda hacky
 #include <dbus/dbus-glib.h>
+#endif
 
 typedef gboolean (* activate_handler)(GtkCellRenderer *cell,
 	GdkEvent *event, 
@@ -17,6 +19,8 @@
 
 void banshee_dbus_compat_thread_init()
 {
+#ifndef WIN32
 	dbus_g_thread_init();
+#endif
 }
 
Index: nautilus-burn.c
===================================================================
--- nautilus-burn.c	(revision 2823)
+++ nautilus-burn.c	(working copy)
@@ -10,16 +10,6 @@
 #include <nautilus-burn.h>
 #endif
 
-void
-nautilus_burn_glue_drive_free(NautilusBurnDrive *drive)
-{
-#if LNB_215
-    nautilus_burn_drive_unref(drive);
-#else
-    nautilus_burn_drive_free(drive);
-#endif
-}
-
 struct NautilusBurnRecorderTrack *
 nautilus_burn_glue_create_track(const char *filename, NautilusBurnRecorderTrackType type)
 {
